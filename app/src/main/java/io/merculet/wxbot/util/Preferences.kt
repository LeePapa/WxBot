package io.merculet.wxbot.util

import android.content.*
import android.net.Uri
import com.gh0u1l5.wechatmagician.spellbook.base.WaitChannel
import com.gh0u1l5.wechatmagician.spellbook.util.BasicUtil
import com.gh0u1l5.wechatmagician.spellbook.util.BasicUtil.tryAsynchronously
import com.gh0u1l5.wechatmagician.spellbook.util.LogUtil
import de.robv.android.xposed.XSharedPreferences
import io.merculet.wxbot.config.Config
import io.merculet.wxbot.config.Config.ACTION_UPDATE_PREF
import io.merculet.wxbot.config.Config.FOLDER_SHARED_PREFS
import io.merculet.wxbot.config.Config.PREFERENCE_PROVIDER_AUTHORITY
import java.io.File
import java.util.concurrent.ConcurrentHashMap

class Preferences(private val preferencesName: String) : SharedPreferences {

    // loadChannel resumes all the threads waiting for the preference loading.
    private val loadChannel = WaitChannel()


    // legacy is prepared for the fallback logic if ContentProvider is not working.
    private var legacy: XSharedPreferences? = null

    // content is the preferences generated by the frond end of Wechat Magician.
    private val content: MutableMap<String, Any?> = ConcurrentHashMap()

    // load reads the shared preferences or reloads the existing preferences
    fun load(context: Context) {
        tryAsynchronously {
            try {
                // Load the shared preferences using ContentProvider.
                val uri = Uri.parse("content://$PREFERENCE_PROVIDER_AUTHORITY/$preferencesName")
                val cursor = context.contentResolver.query(uri, null, null, null, null)
                cursor?.use {
                    while (cursor.moveToNext()) {
                        val key = cursor.getString(0)
                        val type = cursor.getString(2)
                        content[key] = when (type) {
                            "Int" -> cursor.getInt(1)
                            "Long" -> cursor.getLong(1)
                            "Float" -> cursor.getFloat(1)
                            "Boolean" -> (cursor.getString(1) == "true")
                            "String" -> cursor.getString(1)
                            else -> null
                        }
                    }
                }
            } catch (_: SecurityException) {
                // Failed to use the ContentProvider pattern, fallback to XSharedPreferences.
                if (loadChannel.isDone() && legacy != null) {
                    legacy?.reload()
                    return@tryAsynchronously
                }
                val preferencesDir = "${Utils.getPackageName(context)}/$FOLDER_SHARED_PREFS/"
                legacy = XSharedPreferences(File(preferencesDir, "$preferencesName.xml"))
            } finally {
                loadChannel.done()
            }
        }
    }


    // listen registers the updateReceiver to listen the update events from the frontend.
    private val updateReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            loadChannel.wait(2000)
            // If we are using the legacy logic, then just stay with it.
            if (legacy != null) {
                legacy?.reload()
                return
            }
            // Otherwise we completely follow the new ContentProvider pattern.
            if (intent != null) {
                val key = intent.getStringExtra(Config.PROVIDER_PREF_KEY)
                content[key] = intent.extras?.get(Config.PROVIDER_PREF_VALUE)
//                LogUtil.log("key:$key")
//                LogUtil.log("content[key]:${content[key]}")
            }
        }
    }


    fun listen(context: Context) {
        BasicUtil.tryVerbosely {
            context.registerReceiver(updateReceiver, IntentFilter(ACTION_UPDATE_PREF))
        }
    }

    override fun contains(key: String): Boolean = content.contains(key) || legacy?.contains(key) == true

    override fun getAll(): MutableMap<String, *>? = if (legacy != null) legacy!!.all else content

    private fun getValue(key: String): Any? {
        loadChannel.wait(100)
        return all?.get(key)
    }

    private inline fun <reified T> getValue(key: String, defValue: T) = getValue(key) as? T
            ?: defValue

    override fun getInt(key: String, defValue: Int): Int = getValue(key, defValue)

    override fun getLong(key: String, defValue: Long): Long = getValue(key, defValue)

    override fun getFloat(key: String, defValue: Float): Float = getValue(key, defValue)

    override fun getBoolean(key: String, defValue: Boolean): Boolean = getValue(key, defValue)

    override fun getString(key: String, defValue: String): String = getValue(key, defValue)

    override fun getStringSet(key: String, defValue: MutableSet<String>): MutableSet<String> = getValue(key, defValue)

    override fun edit(): SharedPreferences.Editor {
        throw UnsupportedOperationException()
    }

    override fun registerOnSharedPreferenceChangeListener(listener: SharedPreferences.OnSharedPreferenceChangeListener?) {
        throw UnsupportedOperationException()
    }

    override fun unregisterOnSharedPreferenceChangeListener(listener: SharedPreferences.OnSharedPreferenceChangeListener?) {
        throw UnsupportedOperationException()
    }
}
